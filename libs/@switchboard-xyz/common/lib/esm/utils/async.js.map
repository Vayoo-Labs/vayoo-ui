{"version":3,"file":"async.js","sourceRoot":"","sources":["../../../src/utils/async.ts"],"names":[],"mappings":"AAAA;;;GAGG;AACH,MAAM,CAAC,MAAM,KAAK,GAAG,CAAC,EAAU,EAAgB,EAAE,CAChD,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,UAAU,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAExC,MAAM,OAAO,YAAa,SAAQ,KAAK;IACrC,YAAqB,EAAU,EAAE,GAAY;QAC3C,KAAK,CACH,eACE,GAAG;YACD,CAAC,CAAC,IAAI,GAAG,GAAG;YACZ,CAAC,CAAC,mBAAmB,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,UACzD,EAAE,CACH,CAAC;QAPiB,OAAE,GAAF,EAAE,CAAQ;QAQ7B,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC;IACtD,CAAC;CACF;AAED;;;;;GAKG;AACH,MAAM,CAAC,KAAK,UAAU,kBAAkB,CACtC,EAAU,EACV,OAAuC,EACvC,YAAqB;IAErB,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;IAE9D,kDAAkD;IAClD,MAAM,OAAO,GAAG,IAAI,OAAO,CAAQ,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE;QAC/C,UAAU,CAAC,GAAG,EAAE;YACd,8BAA8B;YAC9B,yDAAyD;YACzD,iBAAiB;YACjB,MAAM;YACN,IAAI;YACJ,MAAM,CAAC,IAAI,YAAY,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC,CAAC;QAC7C,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,0EAA0E;IAC5F,CAAC,CAAC,CAAC;IAEH,OAAO,OAAO,CAAC,IAAI,CAAI,CAAC,GAAG,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC;AACjD,CAAC","sourcesContent":["/** Sleep for a given number of milliseconds\n * @param ms number of milliseconds to sleep for\n * @return a promise that resolves when the sleep interval has elapsed\n */\nexport const sleep = (ms: number): Promise<any> =>\n  new Promise((s) => setTimeout(s, ms));\n\nexport class TimeoutError extends Error {\n  constructor(readonly ms: number, msg?: string) {\n    super(\n      `TimeoutError${\n        msg\n          ? \": \" + msg\n          : `timed out after ${Math.round(ms / 1000).toFixed(3)} seconds`\n      }`\n    );\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n\n/** Returns a promise that resolves successfully if returned before the given timeout has elapsed.\n * @param ms the number of milliseconds before the promise expires\n * @param promise the promise(s) to wait for\n * @param timeoutError the error to throw if the promise expires\n * @return the promise result\n */\nexport async function promiseWithTimeout<T>(\n  ms: number,\n  promise: Promise<T> | Array<Promise<T>>,\n  timeoutError?: string\n): Promise<T> {\n  const promises = Array.isArray(promise) ? promise : [promise];\n\n  // create a promise that rejects in N milliseconds\n  const timeout = new Promise<never>((_, reject) => {\n    setTimeout(() => {\n      // for (const p of promises) {\n      //   if (\"unref\" in p && typeof p.unref === \"function\") {\n      //     p.unref();\n      //   }\n      // }\n      reject(new TimeoutError(ms, timeoutError));\n    }, ms).unref(); // dont hold up closing NodeJS process if this is the only timer scheduled\n  });\n\n  return Promise.race<T>([...promises, timeout]);\n}\n"]}