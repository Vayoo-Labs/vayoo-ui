{"version":3,"file":"aggregatorHistoryBuffer.js","sourceRoot":"","sources":["../../../src/accounts/aggregatorHistoryBuffer.ts"],"names":[],"mappings":"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","sourcesContent":["import * as errors from '../errors';\nimport * as types from '../generated';\nimport { SwitchboardProgram } from '../SwitchboardProgram';\nimport { TransactionObject } from '../TransactionObject';\n\nimport {\n  Account,\n  BUFFER_DISCRIMINATOR,\n  OnAccountChangeCallback,\n} from './account';\nimport { AggregatorAccount } from './aggregatorAccount';\n\nimport * as anchor from '@coral-xyz/anchor';\nimport {\n  Commitment,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport { Big, BN } from '@switchboard-xyz/common';\n\nexport interface AggregatorHistoryInit {\n  /** Aggregator account to add a history buffer for. */\n  aggregatorAccount: AggregatorAccount;\n  /** Maximum number of samples to store in a round robin history buffer. */\n  maxSamples: number;\n  /** Alternative keypair that is the authority for the aggregatorAccount and authorized to add a historyBuffer. */\n  aggregatorAuthority?: Keypair;\n  /** Existing keypair to create the history buffer for. Must be a fresh keypair not tied to an existing on-chain account. */\n  keypair?: Keypair;\n}\n\n/**\n * Account type representing a round robin buffer of historical samples.\n *\n * Data: Array<{@linkcode types.AggregatorHistoryRow}>\n */\nexport class AggregatorHistoryBuffer extends Account<\n  Array<types.AggregatorHistoryRow>\n> {\n  static accountName = 'AggregatorHistoryBuffer';\n\n  public size = 28;\n\n  public static getAccountSize(size: number): number {\n    return 12 + size * 28;\n  }\n\n  /** Return a history buffer account initialized to the default values. */\n  public static default(size = 1000): Buffer {\n    const buffer = Buffer.alloc(\n      AggregatorHistoryBuffer.getAccountSize(size),\n      0\n    );\n    BUFFER_DISCRIMINATOR.copy(buffer, 0);\n    return buffer;\n  }\n\n  /**\n   * Decode an aggregators history buffer and return an array of historical samples in ascending order by timestamp.\n   * @params historyBuffer the historyBuffer AccountInfo stored on-chain\n   * @return the array of {@linkcode types.AggregatorHistoryRow} samples\n   */\n  public static decode(\n    historyBuffer: Buffer,\n    startTimestamp?: number,\n    endTimestamp?: number\n  ): Array<types.AggregatorHistoryRow> {\n    const ROW_SIZE = 28;\n\n    if (historyBuffer.length < 12) {\n      return [];\n    }\n\n    const insertIdx = historyBuffer.readUInt32LE(8) * ROW_SIZE;\n\n    const front: Array<types.AggregatorHistoryRow> = [];\n    const tail: Array<types.AggregatorHistoryRow> = [];\n\n    const buffer = historyBuffer.slice(12);\n\n    for (let i = 0; i < buffer.length; i += ROW_SIZE) {\n      if (i + ROW_SIZE > buffer.length) {\n        break;\n      }\n\n      const row = types.AggregatorHistoryRow.fromDecoded(\n        types.AggregatorHistoryRow.layout().decode(buffer, i)\n      );\n\n      if (row.timestamp.eq(new anchor.BN(0))) {\n        break;\n      }\n\n      if (startTimestamp && startTimestamp > row.timestamp.toNumber()) {\n        continue;\n      }\n\n      if (endTimestamp && endTimestamp < row.timestamp.toNumber()) {\n        continue;\n      }\n\n      if (i <= insertIdx) {\n        tail.push(row);\n      } else {\n        front.push(row);\n      }\n    }\n\n    return front.concat(tail);\n  }\n\n  /**\n   * Return an aggregator's assigned history buffer or undefined if it doesn't exist.\n   */\n  static fromAggregator(\n    program: SwitchboardProgram,\n    aggregator: types.AggregatorAccountData\n  ): AggregatorHistoryBuffer | undefined {\n    if (aggregator.historyBuffer.equals(PublicKey.default)) {\n      return undefined;\n    }\n\n    return new AggregatorHistoryBuffer(program, aggregator.historyBuffer);\n  }\n\n  /**\n   * Decode an aggregators history buffer and return an array of historical samples\n   * @params historyBuffer the historyBuffer AccountInfo stored on-chain\n   * @return the array of {@linkcode types.AggregatorHistoryRow} samples\n   */\n  public decode(\n    historyBuffer: Buffer,\n    startTimestamp?: number,\n    endTimestamp?: number\n  ): Array<types.AggregatorHistoryRow> {\n    return AggregatorHistoryBuffer.decode(\n      historyBuffer,\n      startTimestamp,\n      endTimestamp\n    );\n  }\n\n  /**\n   * Fetch an aggregators history buffer and return an array of historical samples\n   * @params aggregator the pre-loaded aggregator state\n   * @return the array of {@linkcode types.AggregatorHistoryRow} samples\n   */\n  public async loadData(\n    startTimestamp?: number,\n    endTimestamp?: number\n  ): Promise<Array<types.AggregatorHistoryRow>> {\n    if (PublicKey.default.equals(this.publicKey)) {\n      return [];\n    }\n    const bufferAccountInfo = await this.program.connection.getAccountInfo(\n      this.publicKey\n    );\n    if (bufferAccountInfo === null) {\n      throw new errors.AccountNotFoundError(\n        'Aggregator History',\n        this.publicKey\n      );\n    }\n    return AggregatorHistoryBuffer.decode(\n      bufferAccountInfo.data,\n      startTimestamp,\n      endTimestamp\n    );\n  }\n\n  /**\n   * Invoke a callback each time an AggregatorAccount's data has changed on-chain.\n   * @param callback - the callback invoked when the aggregator state changes\n   * @param commitment - optional, the desired transaction finality. defaults to 'confirmed'\n   * @returns the websocket subscription id\n   */\n  public onChange(\n    callback: OnAccountChangeCallback<Array<types.AggregatorHistoryRow>>,\n    commitment: Commitment = 'confirmed'\n  ): number {\n    return this.program.connection.onAccountChange(\n      this.publicKey,\n      accountInfo => {\n        callback(this.decode(accountInfo.data));\n      },\n      commitment\n    );\n  }\n\n  /**\n   * Create a history buffer for an aggregator and store the last N samples in a round robin history buffer.\n   * @param program The SwitchboardProgram.\n   * @param payer The account that will pay for the new account.\n   * @param params history buffer configuration parameters.\n   * @return {@linkcode TransactionObject} that will create the AggregatorHistoryBuffer.\n   *\n   * Basic usage example:\n   *\n   * ```ts\n   * import { AggregatorAccount,AggregatorHistoryBuffer } from '@switchboard-xyz/solana.js';\n   * const aggregatorAccount = new AggregatorAccount(program, aggregatorKey);\n   * const aggregator = await aggregatorAccount.loadData();\n   * const [historyBuffer, addHistoryTxn] = await AggregatorHistoryBuffer.createInstructions(program, payer, {\n   *    aggregatorAccount,\n   *    maxSamples: 10000,\n   * });\n   * const aggregatorHistorySignature = await program.signAndSendAll(aggregatorHistoryTxn);\n   * const history = await historyBuffer.loadData();\n   * ```\n   */\n  public static async createInstructions(\n    program: SwitchboardProgram,\n    payer: PublicKey,\n    params: AggregatorHistoryInit\n  ): Promise<[AggregatorHistoryBuffer, TransactionObject]> {\n    const buffer = params.keypair ?? Keypair.generate();\n    program.verifyNewKeypair(buffer);\n\n    const ixns: TransactionInstruction[] = [];\n    const signers: Keypair[] = params.aggregatorAuthority\n      ? [params.aggregatorAuthority, buffer]\n      : [buffer];\n\n    const size = AggregatorHistoryBuffer.getAccountSize(params.maxSamples);\n\n    ixns.push(\n      SystemProgram.createAccount({\n        fromPubkey: payer,\n        newAccountPubkey: buffer.publicKey,\n        space: size,\n        lamports: await program.connection.getMinimumBalanceForRentExemption(\n          size\n        ),\n        programId: program.programId,\n      }),\n      types.aggregatorSetHistoryBuffer(\n        program,\n        { params: {} },\n        {\n          aggregator: params.aggregatorAccount.publicKey,\n          authority: params.aggregatorAuthority\n            ? params.aggregatorAuthority.publicKey\n            : payer,\n          buffer: buffer.publicKey,\n        }\n      )\n    );\n\n    return [\n      new AggregatorHistoryBuffer(program, buffer.publicKey),\n      new TransactionObject(payer, ixns, signers),\n    ];\n  }\n\n  /**\n   * Create a history buffer for an aggregator and store the last N samples in a round robin history buffer.\n   * @param program The SwitchboardProgram.\n   * @param payer The account that will pay for the new account.\n   * @param params history buffer configuration parameters.\n   * @return {@linkcode TransactionObject} that will create the AggregatorHistoryBuffer.\n   *\n   * Basic usage example:\n   *\n   * ```ts\n   * import { AggregatorAccount,AggregatorHistoryBuffer } from '@switchboard-xyz/solana.js';\n   * const aggregatorAccount = new AggregatorAccount(program, aggregatorKey);\n   * const aggregator = await aggregatorAccount.loadData();\n   * const [historyBuffer, addHistorySignature] = await AggregatorHistoryBuffer.create(program, {\n   *    aggregatorAccount,\n   *    maxSamples: 10000,\n   * });\n   * const history = await historyBuffer.loadData();\n   * ```\n   */\n  public static async create(\n    program: SwitchboardProgram,\n    params: AggregatorHistoryInit\n  ): Promise<[AggregatorHistoryBuffer, TransactionSignature]> {\n    const [account, transaction] =\n      await AggregatorHistoryBuffer.createInstructions(\n        program,\n        program.walletPubkey,\n        params\n      );\n    const txnSignature = await program.signAndSend(transaction);\n    return [account, txnSignature];\n  }\n\n  public static collectMetrics(\n    history: Array<types.AggregatorHistoryRow>,\n    minUpdateDelaySeconds: number,\n    period?: number\n  ): AggregatorHistoryMetrics {\n    const endTimestamp = history\n      .map(row => row.timestamp)\n      .reduce((max, ts) => (ts.gt(max) ? ts : max), new BN(0));\n\n    const startTimestamp = period\n      ? history.reduce((val, row) => {\n          const expectedStartTimestamp = endTimestamp.sub(new BN(period));\n          return row.timestamp.gte(expectedStartTimestamp) &&\n            val\n              .sub(expectedStartTimestamp)\n              .abs()\n              .gt(row.timestamp.sub(expectedStartTimestamp).abs())\n            ? row.timestamp\n            : val;\n        }, new BN(0))\n      : history\n          .map(row => row.timestamp)\n          .reduce((min, ts) => (ts.lt(min) ? ts : min), history[0].timestamp);\n\n    const parsedHistory = history.filter(\n      row =>\n        row.timestamp.gte(startTimestamp) && row.timestamp.lte(endTimestamp)\n    );\n\n    const start = parsedHistory.slice(0)[0];\n    const end = parsedHistory.slice(-1)[0];\n\n    const timestamps = parsedHistory.map(r => r.timestamp);\n    const bigValues = parsedHistory.map(r => r.value.toBig());\n\n    const values = bigValues.map(val => Number.parseFloat(val.toString()));\n\n    const minValue = Math.min(...values);\n    const min = parsedHistory.find(r => Number(r.value) === minValue);\n\n    const maxValue = Math.max(...values);\n    const max = parsedHistory.find(r => Number(r.value) === maxValue);\n\n    const actualPeriod = endTimestamp.sub(startTimestamp).toNumber();\n    const numSamples = parsedHistory.length;\n\n    const maxUpdateIntervalWithJitter =\n      minUpdateDelaySeconds + (15 % minUpdateDelaySeconds);\n\n    const averageUpdateDelay =\n      Math.round((actualPeriod / numSamples) * 10000) / 10000;\n    const updateCoefficient =\n      Math.round((averageUpdateDelay / minUpdateDelaySeconds) * 10000) / 10000;\n\n    const averageValue = bigValues\n      .reduce((sum, val) => sum.add(val))\n      .div(numSamples);\n\n    const standardDeviation = bigValues\n      .reduce((sum, val) => sum.add(val.sub(averageValue).pow(2)), new Big(0))\n      .div(numSamples)\n      .sqrt();\n\n    return {\n      history: parsedHistory,\n      period: actualPeriod,\n      numSamples,\n      minUpdateDelaySeconds: minUpdateDelaySeconds,\n      maxUpdateIntervalWithJitter,\n      averageUpdateDelay,\n      updateCoefficient,\n      averageValue: averageValue.toNumber(),\n      standardDeviation: standardDeviation.toNumber(),\n      start,\n      end,\n      min: min!,\n      max: max!,\n    };\n  }\n}\n\nexport type AggregatorHistoryMetrics = {\n  history: Array<types.AggregatorHistoryRow>;\n  period: number;\n  numSamples: number;\n  minUpdateDelaySeconds: number;\n  maxUpdateIntervalWithJitter: number;\n  averageUpdateDelay: number;\n  updateCoefficient: number;\n  averageValue: number;\n  standardDeviation: number;\n  start: types.AggregatorHistoryRow;\n  end: types.AggregatorHistoryRow;\n  min: types.AggregatorHistoryRow;\n  max: types.AggregatorHistoryRow;\n};\n"]}